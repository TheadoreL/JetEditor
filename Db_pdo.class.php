<?php
/*
	Module: Access Database via PDO
	Author: Mean Machine;
	Create @ 2014-12-01;
*/
include_once("Db_pdo_log.class.php");
include_once("config.inc.php");

class db_pdo {
	private	$_pdo;
	private	$_query;
	private	$_connected = false;
	private	$_log;
	private	$_parameters;
	private $_user;
	public	$_queryCount = 0;
	public function __construct($user = 'root') {
		$this -> _user = $user;
		$this -> _log = new db_pdo_log();
		$this -> Connect($user);
		$this -> _parameters = array();
	}
	public function Connect($user) {
		try {
			$users = json_decode(file_get_contents(ROOT_PATH . '/dbuser.profile'), true);
			$dbstr = $users[$user]['dbType'] . ':host=' . $users[$user]['Server'] . '; dbname=' . $users[$user]['dbName'] .'; charset=' . $users[$user]['charset'];
			//$this -> _pdo = new PDO(DB_STRING, DB_USER, DB_PWD);
			$this -> _pdo = new PDO($dbstr, $user, $users[$user]['pwd']);
			$this -> _pdo -> setAttribute(PDO::ATTR_PERSISTENT, true);					//set database to long-connection
			$this -> _pdo -> setAttribute(PDO::ATTR_EMULATE_PREPARES, false);			//Anti SQL Injection
			$this -> _pdo -> setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);	//throw exceptions
			$this -> _pdo -> setAttribute(PDO::ATTR_ORACLE_NULLS, true);				//None -> SQL: Null
			$this -> _connected = true;
		}
		catch (PDOException $e) {
			// exit("Can't Connect to database. Error: ". $this -> ExceptionLog($e -> getMessage()));
			exit("无法连接至数据库。错误： ". $this -> ExceptionLog($e -> getMessage()));
		}
		return $this -> _pdo;
	}
	public function CloseConnection() {
		$this -> _pdo = null;
	}
	private function Init($query, $parameters = "") {
		if (!$this -> _connected)
			$this -> Connect($this -> _user);
		try {
			if (!is_array($parameters))
				$parameters = array($parameters);
			$this -> _parameters = $parameters;
			$this -> _query = $this -> _pdo -> prepare($this -> BuildParams($query, $this -> _parameters));
			if (!empty($this -> _parameters)) {
				if (array_key_exists(0, $parameters)) {
					$parametersType = true;
					array_unshift($this -> _parameters, "");
					unset($this -> _parameters[0]);
				}
			else
				$parametersType = false;
			foreach ($this -> _parameters as $column => $value)
				$this -> _query -> bindParam($parametersType ? intval($column) : ":".$column, $this -> _parameters[$column]);
			$this -> _success = $this -> _query -> execute();
			$this -> _queryCount++;
			}
		}
		catch(PDOException $e) {
			die($this -> ExceptionLog($e -> getMessage(), $this -> BuildParams($query)));
		}
		$this -> _parameters = array();
	}
	private function BuildParams($query, $params = null) {
		if (!empty($params)) {
			$rawStatement = explode(" ", $query);
			foreach ($rawStatement as $value) {
				if (strtolower($value) == 'in')
					return str_replace("(?)", "(".implode(",", array_fill(0, count($params), "?")).")", $query);
			}
			if (DB_DEBUG_MODE) {
				var_dump($params);
				echo "<div>".$query."</div><hr />";
			}
			return $query;
		}
	}
	public function query($query, $params = null, $fetchmode = PDO::FETCH_ASSOC) {
		$query = trim($query);
		$rawStatement = explode(" ", $query);
		
		$statement = strtolower($rawStatement[0]);
		if ($statement === 'select' || $statement === 'show')
		{
			$this -> Init($query, $params);
			return $this -> _query -> fetchAll($fetchmode);
		}
		elseif ($statement === 'insert' || $statement === 'update' || $statement === 'delete')
		{
			$this -> Init($query, $params);
			return $this -> _query -> rowCount();
		}
		elseif ($statement === 'call')
			return $this->callStoredProcedure($query);
		else
			return NULL;
	}
	public function lastInsertId() {
		return $this -> _pdo -> lastInsertId();
	}
	public function column($query, $params = null) {
		$this -> Init($query, $params);
		return $this -> _query -> fetchAll(PDO::FETCH_COLUMN);
	}
	public function row($query, $params = null, $fetchmode = PDO::FETCH_ASSOC) {
		$this -> Init($query,$params);
		return $this -> _query -> fetch($fetchmode);
	}
	public function single($query, $params = null) {
		$this -> Init($query, $params);
		return $this -> _query -> fetchColumn();
	}
	private function ExceptionLog($message, $sql = "") {
		// $exception  = 'Unhandled Exception. <br />';
		$exception  = '未捕获到的异常<br />';
		$exception .= $message;
		// $exception .= "<br /><font style='color: red'>You can find this Error in the Backend Log.</font>";
		$exception .= "<br /><font style='color: red'>可在后台日志中找到关于此次出错的详细信息。</font>";
		if(!empty($sql))
			$message .= "\r\nRaw SQL: ".$sql;
		$this -> _log -> write($message);
		return $exception;
	}
	
	private function callStoredProcedure($query)
	{
		$this -> _query = $this->_pdo->prepare($query);
		$this -> _query -> execute();
		$res = $this->_query->fetchAll($fetchmode);
		do $this->_query->fetchAll($fetchmode); //consume extra result set generated by SP calling
		while ($this->_query->nextRowSet());
		return $res;
	}
}
?>